{-
    - Overloading
    - Steps to create Type Class and Instances
    - The Eq type class
        - Defining the Type Class
        - Defining multiple instances
        - Improving our Eq type class with mutual recursion (and MCD)
        - Defining an instance for a parameterizing type
    - The WeAccept Type Class
    - The Container Type Class
    - Exploring Ord type class (Subclassing)
    - Deriving
        - Deriving can go wrong
-}

{-
    Overloading

    Date:
        1. The time at which an event occurs
        2. A social engagement  that often has a romantic character (unless Joe
        gets friend-zone)
        3. The act of estimating or computering a date or chronology (date a fossil)

    In programming we say the word date is overloaded but it has multiple definitions
    for the same name

    Overloading:
        1. To put too large overload on or in (something)
        2. Having multiple implementations of a function with the same name
        3. (In Haskell) Having multiple implementations of a function or value
        with the same name
-}

{-
    Steps to create Type Classes and Instances
    1. Create a type class stating some bahaviors
    2. Make a type an instance of that type class with the implementation of
    those behaviors for that specific type
-}

{-
    The Eq type class

    class Eq a where
        (==) :: a -> a -> Bool
        (\=) :: a -> a -> Bool
-}

-- Defining an instance for the Eq type class
data PaymentMethod = Cash | Card | CC -- CC stands for Cryptocurrency

instance Eq PaymentMethod where
    -- implementation of  ==
    Cash == Cash = True
    Card == Card = True
    CC == CC = True
    _ == _ = False -- Works as an otherwise case

    -- implementation of /=
    Cash /= Cash = False
    Card /= Card = False
    CC /= CC = False
    _ /= _ = True -- Works as an otherwise case

type User = (String, PaymentMethod)

samePM :: User -> User -> Bool
samePM (_, pm1) (_, pm2) = pm1 == pm2

{-
    Improving out Eq type class with Mutual Recursion

    class Eq a where
        (==), (/=) :: a -> a -> Bool
        x /= y = not (x == y)
        x == y = not (x /= y)

    with this implementation of class Eq we can define only one of the cases
    because the compiler can infer the behavior of one with the other

    instance Eq PaymentMethod where
        Cash == Cash = True
        Card == Card = True
        CC == CC = True
        _ == _ = False

    Its called Minimum Complete Definition. Because it is the minimum you have to
    implement to get a fully functional instance

    :info Eq

    type Eq :: * -> Constraint -- It means Eq is takes a concrete type and return a Constraint
    class Eq a where
      (==) :: a -> a -> Bool
      (/=) :: a -> a -> Bool
      {-# MINIMAL (==) | (/=) #-}
      ....

    it means you have to implement (==) or (/=) you don't need them both
-}

-- Create Date Type
data Blockchain = Cardano | Ethereum | Bitcoin

-- Create an minimum instance of Eq implementing only the (==) part of it
instance Eq Blockchain where
    Cardano == Cardano = True
    Ethereum == Ethereum = True
    Bitcoin == Bitcoin = True
    _ == _ = False

{-
    Defining an instance for a parameterized type

    data Box a =  Empty | Box a

    > :kind Box
    Box :: * -> *

    > :kind Box Int
    Box Int :: *

    You cannot create an instance of Box directly but you can create an instance
    of a Box that takes a concrete type, like:

    instance Eq (Box Int) where
    ...

    instance Eq (Box String) where
    ...

    instance Eq (Box PaymentMethod) where
    ...

    Solve this with type variables

    instance Eq (Box a) where
    ...
-}
data Box a = Empty | Has a

-- Use "(Eq a) =>" to constrain the type of a to be an instance of the Eq type
instance (Eq a) => Eq (Box a) where
    -- If the two boxes contains the same element the boxes themselves are equal
    Has x == Has y = x == y
    Empty == Empty = True
    -- otherwise case
    _ == _ = False

{-
    data Choice = Yes | No

    test9 = Has Yes == Has No -- Doesn't work: Choice is no instance of Eq
-}

{-
    The WeAccept Type Class
-}

-- Function to check if we accept that payment method
weAcceptPayment :: PaymentMethod -> Bool
weAcceptPayment p = case p of
    Cash -> True
    Card -> True
    CC   -> False

-- Function to check if we accept that blockchain
weAcceptBlockchain :: Blockchain -> Bool
weAcceptBlockchain b = case b of
    Bitcoin  -> True
    Ethereum -> False
    Cardano  -> True

-- Country Type
-- > countryName function is auto generated by haskell
newtype Country = Country { countryName :: String }

-- Function to check if we accept that country
weAcceptCountry :: Country -> Bool
weAcceptCountry c = case countryName c of
    "Mordor" -> False
    _        -> True

{-
    Creating the WeAccept type class

    class WeAccept a where
        weAccept :: a -> Bool

    >:kind WeAccept
    WeAccept :: * -> Constraint -- Takes a concrete and returns a constraint
-}

class WeAccept a where
    weAccept :: a -> Bool

instance WeAccept PaymentMethod where
    weAccept x = case x of
        Cash -> True
        Card -> True
        CC   -> False

instance WeAccept Blockchain where
    weAccept x = case x of
        Bitcoin  -> True
        Ethereum -> False
        Cardano  -> True

instance WeAccept Country where
    weAccept x = case countryName x of
        "Mordor" -> False
        _        -> True

instance (WeAccept a) => WeAccept (Box a) where
    weAccept (Has x) = weAccept x
    weAccept Empty   = False

-- Creating fancyFunction
fancyFunction :: (WeAccept a) => a -> String
fancyFunction x =
    if weAccept x
        then "Do something fancy"
        else "Don't do it!"

{-
    The Constains Type Class

    data Box a       = Empty          | Has a        deriving (Show)
    data Present t a = EmptyPresent t | PresentFor a deriving (Show)

    >:kind Box
    Box :: * -> *

    >:kind Present
    Present :: * -> * -> *
-}

class Container c where
    isEmpty  :: c a -> Bool
    contains :: (Eq a) => c a -> a -> Bool
    replace  :: c a -> b -> c b

{-
    - isEmpty takes a container of type a and return True or False

    - contains takes a container of type a and an element of type a
    and returns True or False

    - replace takes a container of type a and an element of type b
    and returns a container of type b
-}

-- data Box a = Empty | Has a deriving (Show)
instance Container Box where
    isEmpty Empty = True
    isEmpty _     = False

    contains (Has x) y = x == y
    contains Empty   _ = False

    replace _ x = Has x

data Present t a = EmptyPresent t | PresentFor t a deriving (Show)

instance Container (Present t) where
    isEmpty (EmptyPresent _) = True
    isEmpty _                = False

    contains (PresentFor _ x) y = x == y
    contains (EmptyPresent _) _ = False

    replace (PresentFor tag _) x = PresentFor tag x
    replace (EmptyPresent tag) x = PresentFor tag x

-- A function that matches a value to the value inside the container
guessWhatIsInside :: (Container c, Eq a) => c a -> a -> String
guessWhatIsInside x y
    | x `contains` y = "You guessed!"
    | otherwise      = "Meh! You're wrong"

{-
    Exploring the Ord type class (Subclass)

    >:info Ord

    type Ord :: * -> Constraint
    class Eq a => Ord a where  -- That 'Eq a =>' is new in class definitions
      compare :: a -> a -> Ordering
      (<) :: a -> a -> Bool
      (<=) :: a -> a -> Bool
      (>) :: a -> a -> Bool
      (>=) :: a -> a -> Bool
      max :: a -> a -> a
      min :: a -> a -> a
      {-# MINIMAL compare | (<=) #-}
-}
instance (Ord a) => Ord (Box a) where
    Has x `compare` Has y = x `compare` y
    Empty `compare` Has _ = LT
    Has _ `compare` Empty = GT
    Empty `compare` Empty = EQ

{-------------------------------------------------------------------------------
    Deriving

    Using deriving you can get the instance of Type Class without manually
    implementing instances of them

    Deriving seems perfect, but. Not all type classes can be derived, and also,
    deriving can go wrong.
-}
data Choice = No | Idk | Yes deriving (Eq, Ord, Show, Bounded, Enum)

{-
    Deriving going wrong

    data PaymentMethod = Cash | Card | CC deriving (Eq, Ord)

    in this case Cash < Card, Cash < CC and Card < CC the Ord deriving respects
    the order that they are declared in the data structure definition

    data Box a = Empty | Has a deriving (Eq, Ord)

    ----------------------------------------------------------------------------

    data Length = M Double | Km Double deriving (Eq)

    M 1000 == Km 1 -- False

    In this case the haskell compiler does a default implementation and the match
    above does not work because the compiler has no way to know how to different
    constructor relate to each other

    Below is how the compiler will just implement when using deriving Eq

    instance Eq Length where
        (==) (M x) (M y)   = x == y
        (==) (Km x) (Km y) = x == y
        (==) _ _           = False
-}
data Length = M Double | Km Double

-- Manually implementing the instance of Length for Eq
instance Eq Length where
    (==) (M x) (M y)   = x == y
    (==) (Km x) (Km y) = x == y
    (==) (M x) (Km y)  = x == (y * 1000)
    (==) (Km x) (M y)  = (x * 1000) == y

{-
    Tips for real-world code:

    - Everything explained here applies to all the type classes.

    - We don't define type classes that often. Usually, the ones that comes
    built-in with Haskell are all we need.

    - We don't implement instances quite a lot. And usually just deriving is good
    enough (all good to check and test for it). Derive first than just manually
    define instance when they are needed.

    - You can peek the minimum behaviors of a Type Class using :info in GHCI. When
    defining an instance just implement the minimum.
-}

--------------------------------------------------------------------------------

-- Assert Tests With it
assert :: Bool -> Bool -> String -> String
assert expr res id
    | not expr && not res || expr && res     = id ++ " passed"
    | not expr && res     || expr && not res = "Error on " ++ id

-- Main it the test block here
main :: IO ()
main = do
    -- implementing payment method
    putStrLn $ assert (Card == Card) True "Test1"
    putStrLn $ assert (CC /= Card) True "Test2"

    -- PaymentMethod with User (String, PaymentMethod)
    putStrLn $ assert (samePM ("Bob", CC) ("David", CC)) True "Test3"
    putStrLn $ assert (samePM ("Bob", Card) ("David", CC)) False "Test4"

    -- Block Chain Example with minimum implementation
    putStrLn $ assert (Cardano == Cardano) True "Test5"

    -- Instances of Eq combined with 'data Box a = Empty | Box a'
    putStrLn $ assert (Has Cardano == Has Cardano) True "Test6"
    putStrLn $ assert (Has Card /= Empty) True "Test7"
    putStrLn $ assert (Has Bitcoin /= Has Bitcoin) False "Test8"

    -- WeAccept type class
    putStrLn $ assert (weAccept Cardano) True "Test10"
    putStrLn $ assert (weAccept CC == False) True "Test11"
    putStrLn $ assert (weAccept (Country "Mordor")) False "Test12"
    putStrLn $ assert (weAccept (Has Bitcoin)) True "Test13"

    -- Fancy Function
    putStrLn $ fancyFunction Cardano -- Test14
    putStrLn $ fancyFunction Card -- Test15
    putStrLn $ fancyFunction (Country "Mordor") -- Test16
    putStrLn $ fancyFunction (Has Bitcoin) -- Test17

    -- instances of Container for Box
    putStrLn $ assert (Has False `contains` False) True "Test18"
    putStrLn $ assert (isEmpty (Has 'a')) False "Test19"

    -- instances of Container for Present
    putStrLn $ assert (PresentFor "Tommy" 5 `contains` 5) True "Test19"
    putStrLn $ "Test20: " ++ (show $ PresentFor "Tommy" 5 `replace` "Arduino")

    -- Guess What's is inside Function
    putStrLn $ "Test21: " ++ (guessWhatIsInside (PresentFor "Mary" "A Raspberry Pi") "A pony")
    putStrLn $ "Test22: " ++ (guessWhatIsInside (Has 1) 15)

    -- Instance of Ord for (Box a)
    putStrLn $ assert (Has 9 >= Has 5) True "Test23"
    putStrLn $ assert ((Empty `compare` Has 0) == LT) True "Test24"

    -- Deriving (Using compiler auto implementation of instances)
    putStrLn $ assert (Yes /= No) True "Test24"
    putStrLn $ assert (Yes > No) True "Test25"
    putStrLn $ "Test26: " ++ (show Yes)
    putStrLn $ "Test27: " ++ (show (minBound::Choice)) -- Minimum Value
    putStrLn $ "Test28: " ++ (show $ succ Idk) -- Successor

    -- Deriving Goes Wrong > Manually implementing instances to fix
    putStrLn $ assert (M 1 == M 1) True "Test69"
    putStrLn $ assert (Km 2 == Km 3) False "Test70"
    putStrLn $ assert (Km 2 == M 3000) False "Test71"
    putStrLn $ assert (M 2000 == Km 2) True "Test72"
